<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
      }
    </style>

    <script src="https://unpkg.com/three"></script>
    <script src="./node_modules/3d-force-graph/dist/3d-force-graph.js"></script>
    <script src="https://unpkg.com/dat.gui"></script>
    <script
      type="module"
      src="./node_modules/three/examples/js/loaders/RGBELoader.js"
    ></script>
    <script type="module" src="https://unpkg.com/d3-force-limit"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.8.0/d3.min.js"></script>
  </head>

  <body onresize="resizeGraph()">
    <div id="3d-graph" style="width: 100%; height: 100%"></div>

    <script type="module">
      import { FilmPass } from "https://cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/FilmPass.js";
      import { UnrealBloomPass } from "https://cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/UnrealBloomPass.js";
      import { FontLoader } from "https://cdn.skypack.dev/three@0.136/examples/jsm/loaders/FontLoader.js";

      // require("three/examples/js/loaders/RGBELoader.js");

      const hdrEquirect = new THREE.RGBELoader().load(
        "./src/empty_warehouse_01_2k.hdr",
        () => {
          hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
        }
      );

      const textureLoader = new THREE.TextureLoader();
      const normalMapTexture = textureLoader.load("./lib/normal.jpg");
      normalMapTexture.wrapS = THREE.RepeatWrapping;
      normalMapTexture.wrapT = THREE.RepeatWrapping;
      // normalMapTexture.repeat.set(1, 1);

      const unknownSphereRadius = 100;
      const knownSphereRadius = null;
      function spherePosition(radius, coord_1, coord_2) {
        return Math.sqrt(radius ** 2 - coord_1 ** 2 - coord_2 ** 2);
      }
      function nodePosition(unknown, coord_1, coord_2) {
        return unknown
          ? spherePosition(unknownSphereRadius, coord_1, coord_2)
          : spherePosition(knownSphereRadius, coord_1, coord_2);
      }

      // graph config
      const Graph = ForceGraph3D()
        .nodeId("id")
        .linkSource("from")
        .linkTarget("to")
        .nodeLabel("name")
        .nodeVal((n) => {
          return 1.4 ** n.size;
        })
        .nodeThreeObject(
          (n) =>
            new THREE.Mesh(
              n.category == "institution" || n.category == "person"
                ? new THREE.SphereGeometry(1 + n.size, 0)
                : new THREE.IcosahedronGeometry(1 + n.size, 0),
              new THREE.MeshPhysicalMaterial({
                // color: Math.round(Math.random() * Math.pow(2, 24)),
                color: n.unknown ? 0x171717 : assignNodeColors(n.community),
                side: THREE.DoubleSide,
                // clearcoat: 1.0,
                // clearcoatRoughness: 0.5,
                // metalness: 0.9,
                // roughness: 0.5,
                // reflectivity: 1,
                // envMap: hdrEquirect,
                // envMapIntensity: 0.5,
              })
            )
        )
        .nodeOpacity(0.7)
        .nodeAutoColorBy("community")
        .linkLabel("edge_type")
        .linkAutoColorBy("edge_type")
        .linkWidth((e) => e.edge_importance_normalised + 0.4)
        .linkCurvature(0.2)
        .linkOpacity(0.5)
        // .linkCurvature(({ id }) => Math.random() * 0.7)
        // .linkCurveRotation(({ id }) => Math.random() * 2 * Math.PI)
        // .linkResolution(2)
        // .backgroundColor("#0000ff")
        .backgroundColor("#171717")
        // Click on node to approach it
        .onNodeClick((node) => {
          const distance = 40;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

          Graph.cameraPosition(
            {
              // new position
              x: node.x * distRatio,
              y: node.y * distRatio,
              z: node.z * distRatio,
            },
            node, // lookAt ({ x, y, z })
            3000 // ms transition duration
          );
        });
      // .d3Force(
      //   "limit",
      //   d3
      //     .forceLimit()
      //     .x0((n) => -nodePosition(n.unknown, n.y, n.z))
      //     .x1((n) => nodePosition(n.unknown, n.y, n.z))
      //     .y0((n) => -nodePosition(n.unknown, n.x, n.z))
      //     .y1((n) => nodePosition(n.unknown, n.x, n.z))
      //     .z0((n) => -nodePosition(n.unknown, n.x, n.y))
      //     .z1((n) => nodePosition(n.unknown, n.x, n.y))
      //     // .cushionWidth(1000)
      //     .cushionStrength(0.0001)
      // );

      // get data
      const gData = fetch("./data/wiki.json").then((r) => r.json());

      gData.then((data) =>
        Graph(document.getElementById("3d-graph")).graphData(data)
      );

      document.addEventListener("keydown", onDocumentKeyDown, false);
      function onDocumentKeyDown(event) {
        var keyCode = event.which;
        if (
          keyCode == 81 // q for refit view
        ) {
          Graph.zoomToFit(
            3000 // ms transition duration
          );
        } else if (keyCode == 82) {
          setZPosition();
        } else if (keyCode == 83) {
          Graph.graphData(gData.nodes.filter((n) => n.unknown));
        }
      }

      function assignNodeColors(property) {
        const remainder = property % 6;
        if (remainder == 0) {
          return 0xee2997;
        } else if (remainder == 1) {
          return 0xa37e6e;
        } else if (remainder == 2) {
          return 0x773264;
        } else if (remainder == 3) {
          return 0xc9a33b;
        } else if (remainder == 4) {
          return 0xea3609;
        } else {
          return 0x773264;
        }
      }

      function resizeGraph() {
        if (Graph) {
          var height = document.getElementById("3d-graph").clientHeight;
          var width = document.getElementById("3d-graph").clientWidth;

          Graph.width(width);
          Graph.height(height);
          Graph.controls().handleResize();
        }
      }

      // fog
      // let fogColor = new THREE.Color(0x171717);
      // Graph.scene().fog = new THREE.Fog(fogColor, 100, 1500);

      // // unknown center
      const blackholeGeometry = new THREE.IcosahedronGeometry(130, 0);
      const blackholeMaterial = new THREE.MeshPhysicalMaterial({
        roughness: 0.2,
        transmission: 1,
        thickness: 0.1, // Add refraction!
        envMap: hdrEquirect,
        envMapIntensity: 0.5,
        // normalScale: new THREE.Vector2(0.1),
        // normalMap: normalMapTexture,
        // clearcoatNormalMap: normalMapTexture,
        // clearcoatNormalScale: new THREE.Vector2(1),
      });
      const blackhole = new THREE.Mesh(blackholeGeometry, blackholeMaterial);
      Graph.scene().add(blackhole);

      // complex plane
      const planeGeometry = new THREE.BoxGeometry(1000, 1000, 20);
      const planeMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x777777,
        roughness: 0.2,
        transmission: 1,
        thickness: 1,
        reflectivity: 0.1,
        // envMap: hdrEquirect,
        // envMapIntensity: 0.5,
        // normalScale: new THREE.Vector2(1),
        // normalMap: normalMapTexture,
        // clearcoatNormalMap: normalMapTexture,
        // clearcoatNormalScale: new THREE.Vector2(1),
      });
      const plane = new THREE.Mesh(planeGeometry, planeMaterial);
      // mesh.position.set(0, 0, -200);
      Graph.scene().add(plane);
      plane.visible = false;

      // gui
      var gui = new dat.GUI();
      var parameters = {
        mode: "3d",
        filterNodes: "none",
        rotate: false,
      };
      var mode = gui
        .add(parameters, "mode", { "3D": "3d", "2D": "2d", Geo: "geo" })
        .name("Mode")
        .listen();
      var filterNodes = gui
        .add(parameters, "filterNodes", [
          "none",
          "dataset",
          "deployment",
          "technology",
          "institution",
        ])
        .name("Filter nodes")
        .listen();
      var rotate = gui.add(parameters, "rotate").name("Rotate").listen();

      // mode
      mode.onChange((modeNewValue) => {
        if (modeNewValue == "3d") {
          Graph.d3Force(
            "limit",
            d3
              .forceLimit()
              .radius((node) => node.size)
              .x0((n) => -nodePosition(n.unknown, n.y, n.z))
              .x1((n) => nodePosition(n.unknown, n.y, n.z))
              .y0((n) => -nodePosition(n.unknown, n.x, n.z))
              .y1((n) => nodePosition(n.unknown, n.x, n.z))
              .z0((n) => -nodePosition(n.unknown, n.x, n.y))
              .z1((n) => nodePosition(n.unknown, n.x, n.y))
              .cushionWidth(0)
              .cushionStrength(0.0001)
          );
          blackhole.visible = true;
          plane.visible = false;
        } else if (modeNewValue == "2d") {
          console.log("flatten");
          Graph.Graph.d3Force(
            "limit",
            d3
              .forceLimit()
              .radius((node) => node.size)
              .x0((n) => -10000)
              .x1((n) => 10000)
              .y0((n) => -10000)
              .y1((n) => 10000)
              .z0((n) => (n.unknown ? -150 : 50))
              .z1((n) => (n.unknown ? -50 : 90))
              .cushionWidth(0)
              .cushionStrength(0.0001)
          );
          blackhole.visible = false;
          plane.visible = true;
        } else if (modeNewValue == "geo") {
          Graph.d3Force(
            "limit",
            d3
              .forceLimit()
              .radius((node) => node.size)
              .x0((n) => (n.longitude == null ? -10000 : 10 * n.longitude - 20))
              .x1((n) => (n.longitude == null ? 10000 : 10 * n.longitude + 20))
              .y0((n) =>
                n.latitude == null ? -10000 : 20 * (n.latitude - 45) - 20
              )
              .y1((n) =>
                n.latitude == null ? 10000 : 20 * (n.latitude - 45) + 20
              )
              .z0((n) => -20)
              .z1((n) => 20)
              .cushionWidth(0)
              .cushionStrength(0.0000000001)
          );
          blackhole.visible = false;
          plane.visible = false;
        }
        Graph.d3ReheatSimulation();
      });

      filterNodes.onFinishChange((newFilterNodesValue) => {
        // console.log(gData);
        gData.then((data) => {
          if (newFilterNodesValue == "none") {
            Graph.graphData(data);
          } else {
            const filteredNodes = data.nodes.filter(
              (n) => n.category == newFilterNodesValue
            );
            // console.log(filteredNodes);
            const filteredNodesIds = [];
            JSON.stringify(filteredNodes, (key, value) => {
              if (key === "id") filteredNodesIds.push(value);
              return value;
            });
            // console.log(filteredNodesIds);
            const filteredLinks = data.links.filter(
              (e) =>
                filteredNodesIds.includes(e.source.id) &
                filteredNodesIds.includes(e.target.id)
            );
            // console.log(filteredLinks);
            const filteredData = { nodes: filteredNodes, links: filteredLinks };
            console.log(filteredData);
            Graph.graphData(filteredData);
          }
        });
        Graph.graphData().nodes.forEach((n) => {
          n.x = 100 * Math.random();
          n.y = 100 * Math.random();
          n.z = 100 * Math.random();
        });
      });

      // rotation
      let angle = 0;
      const distance = 1000;
      rotate.onChange((newValue) => {
        setInterval(() => {
          if (parameters.rotate) {
            Graph.cameraPosition({
              x: distance * Math.sin(angle),
              z: distance * Math.cos(angle),
            });
            angle += Math.PI / 300;
          }
        }, 16);
      });

      // title
      const loader = new FontLoader();
      loader.load("./lib/helvetiker_regular.typeface.json", function (font) {
        const color = 0x006699;

        const matDark = new THREE.LineBasicMaterial({
          color: color,
          side: THREE.DoubleSide,
        });

        const matLite = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
        });

        const message = "SECURITY VISION";

        const shapes = font.generateShapes(message, 20); // font size

        const geometry = new THREE.ShapeGeometry(shapes);

        geometry.computeBoundingBox();

        const xMid =
          -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

        const textHeight = 0;
        const textDepth = 1350;

        geometry.translate(xMid, textHeight, textDepth);

        // make shape ( N.B. edge view not visible )

        const text = new THREE.Mesh(geometry, matLite);
        text.position.z = -10;
        Graph.scene().add(text);

        // make line shape ( N.B. edge view remains visible )

        const holeShapes = [];

        for (let i = 0; i < shapes.length; i++) {
          const shape = shapes[i];

          if (shape.holes && shape.holes.length > 0) {
            for (let j = 0; j < shape.holes.length; j++) {
              const hole = shape.holes[j];
              holeShapes.push(hole);
            }
          }
        }

        shapes.push.apply(shapes, holeShapes);

        const lineText = new THREE.Object3D();

        for (let i = 0; i < shapes.length; i++) {
          const shape = shapes[i];

          const points = shape.getPoints();
          const geometry = new THREE.BufferGeometry().setFromPoints(points);

          geometry.translate(xMid, textHeight, textDepth);

          const lineMesh = new THREE.Line(geometry, matDark);
          lineText.add(lineMesh);
        }

        Graph.scene().add(lineText);
      });

      // Passes
      const filmPass = new FilmPass(
        0.8, // noise intensity
        0, // scanline intensity
        0, // scanline count
        false // grayscale
      );
      Graph.postProcessingComposer().addPass(filmPass);
    </script>
  </body>
</html>
