<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
      }
    </style>

    <script src="//unpkg.com/three"></script>
    <script src="node_modules/3d-force-graph/dist/3d-force-graph.js"></script>
    <script src="//unpkg.com/dat.gui"></script>
    <script
      type="module"
      src="node_modules/three/examples/js/loaders/RGBELoader.js"
    ></script>
    <script type="module" src="//unpkg.com/d3-force-limit"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/d3/4.8.0/d3.min.js"></script>
  </head>

  <body onresize="resizeGraph()">
    <div id="3d-graph" style="width: 100%; height: 100%"></div>

    <script type="module">
      import { FilmPass } from "https://cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/FilmPass.js";
      import { UnrealBloomPass } from "https://cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/UnrealBloomPass.js";
      import { FontLoader } from "https://cdn.skypack.dev/three@0.136/examples/jsm/loaders/FontLoader.js";

      // require("three/examples/js/loaders/RGBELoader.js");

      const hdrEquirect = new THREE.RGBELoader().load(
        "src/empty_warehouse_01_4k.hdr",
        () => {
          hdrEquirect.mapping = THREE.EquirectangularReflectionMapping;
        }
      );

      const textureLoader = new THREE.TextureLoader();
      const normalMapTexture = textureLoader.load("lib/normal.jpg");
      normalMapTexture.wrapS = THREE.RepeatWrapping;
      normalMapTexture.wrapT = THREE.RepeatWrapping;
      // normalMapTexture.repeat.set(1, 1);

      const unknownSphereRadius = 100;
      const knownSphereRadius = 400;
      function spherePosition(radius, coord_1, coord_2) {
        return Math.sqrt(radius ** 2 - coord_1 ** 2 - coord_2 ** 2);
      }

      const Graph = ForceGraph3D()(document.getElementById("3d-graph"))
        .jsonUrl("data/wiki.json")
        .nodeId("id")
        .linkSource("from")
        .linkTarget("to")
        .nodeLabel("name")
        .nodeVal((n) => {
          return 1.4 ** n.size;
        })
        .nodeThreeObject(
          (n) =>
            new THREE.Mesh(
              n.category == "institution" || n.category == "person"
                ? new THREE.SphereGeometry(1 + n.size, 0)
                : new THREE.IcosahedronGeometry(1 + n.size, 0),
              new THREE.MeshPhysicalMaterial({
                // color: Math.round(Math.random() * Math.pow(2, 24)),
                color: n.unknown ? 0x171717 : assignNodeColors(n.community),
                side: THREE.DoubleSide,
                // clearcoat: 1.0,
                // clearcoatRoughness: 0.5,
                // metalness: 0.9,
                // roughness: 0.5,
                // reflectivity: 1,
                // envMap: hdrEquirect,
                // envMapIntensity: 0.5,
              })
            )
        )
        .nodeOpacity(0.7)
        .nodeAutoColorBy("community")
        .linkLabel("edge_type")
        .linkAutoColorBy("edge_type")
        .linkWidth((e) => e.edge_importance_normalised + 0.4)
        .linkCurvature(0.2)
        .linkOpacity(0.5)
        // .linkCurvature(({ id }) => Math.random() * 0.7)
        // .linkCurveRotation(({ id }) => Math.random() * 2 * Math.PI)
        // .linkResolution(2)
        // .backgroundColor("#0000ff")
        .backgroundColor("#171717")
        // Click on node to approach it
        .onNodeClick((node) => {
          const distance = 40;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

          Graph.cameraPosition(
            {
              // new position
              x: node.x * distRatio,
              y: node.y * distRatio,
              z: node.z * distRatio,
            },
            node, // lookAt ({ x, y, z })
            3000 // ms transition duration
          );
        })
        .d3Force(
          "limit",
          d3
            .forceLimit()
            .x0(
              (n) =>
                n.unknown
                  ? -spherePosition(unknownSphereRadius, n.y, n.z)
                  : -spherePosition(knownSphereRadius, n.y, n.z)
              // : -100000
            )
            .x1(
              (n) =>
                n.unknown
                  ? spherePosition(unknownSphereRadius, n.y, n.z)
                  : spherePosition(knownSphereRadius, n.y, n.z)
              // : 100000
            )
            .y0(
              (n) =>
                n.unknown
                  ? -spherePosition(unknownSphereRadius, n.x, n.z)
                  : -spherePosition(knownSphereRadius, n.x, n.z)
              // : -100000
            )
            .y1(
              (n) =>
                n.unknown
                  ? spherePosition(unknownSphereRadius, n.x, n.z)
                  : spherePosition(knownSphereRadius, n.x, n.z)
              // : 100000
            )
            .z0(
              (n) =>
                n.unknown
                  ? -spherePosition(unknownSphereRadius, n.x, n.y)
                  : -spherePosition(knownSphereRadius, n.x, n.y)
              // : -100000
            )
            .z1(
              (n) =>
                n.unknown
                  ? spherePosition(unknownSphereRadius, n.x, n.y)
                  : spherePosition(knownSphereRadius, n.x, n.y)
              // : 100000
            )
            // .cushionWidth(1000)
            .cushionStrength(0.0001)
        );

      document.addEventListener("keydown", onDocumentKeyDown, false);
      function onDocumentKeyDown(event) {
        var keyCode = event.which;
        if (
          keyCode == 81 // q for refit view
        ) {
          Graph.zoomToFit(
            3000 // ms transition duration
          );
        } else if (keyCode == 82) {
          setZPosition();
        }
      }

      function assignNodeColors(property) {
        const remainder = property % 6;
        if (remainder == 0) {
          return 0xee2997;
        } else if (remainder == 1) {
          return 0xa37e6e;
        } else if (remainder == 2) {
          return 0x773264;
        } else if (remainder == 3) {
          return 0xc9a33b;
        } else if (remainder == 4) {
          return 0xea3609;
        } else {
          return 0x773264;
        }
      }

      function resizeGraph() {
        if (Graph) {
          var height = document.getElementById("3d-graph").clientHeight;
          var width = document.getElementById("3d-graph").clientWidth;

          Graph.width(width);
          Graph.height(height);
          Graph.controls().handleResize();
        }
      }

      // fog
      // let fogColor = new THREE.Color(0x171717);
      // Graph.scene().fog = new THREE.Fog(fogColor, 100, 1500);

      // // unknown center
      const unknownGeometry = new THREE.IcosahedronGeometry(130, 0);
      const unknownMaterial = new THREE.MeshPhysicalMaterial({
        roughness: 0.2,
        transmission: 1,
        thickness: 0.1, // Add refraction!
        envMap: hdrEquirect,
        envMapIntensity: 0.5,
        // normalScale: new THREE.Vector2(0.1),
        // normalMap: normalMapTexture,
        // clearcoatNormalMap: normalMapTexture,
        // clearcoatNormalScale: new THREE.Vector2(1),
      });
      const unknown = new THREE.Mesh(unknownGeometry, unknownMaterial);
      Graph.scene().add(unknown);

      // // basic plane
      // const planeGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
      // const planeMaterial = new THREE.MeshLambertMaterial({
      //   color: 0x171717,
      //   side: THREE.DoubleSide,
      // });
      // const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
      // Graph.scene().add(mesh);

      // complex plane
      // const planeGeometry = new THREE.BoxGeometry(1000, 1000, 20);
      // const planeMaterial = new THREE.MeshPhysicalMaterial({
      //   color: 0x777777,
      //   roughness: 0.2,
      //   transmission: 1,
      //   thickness: 1,
      //   reflectivity: 0.1,
      //   envMap: hdrEquirect,
      //   envMapIntensity: 0.5,
      //   normalScale: new THREE.Vector2(1),
      //   normalMap: normalMapTexture,
      //   clearcoatNormalMap: normalMapTexture,
      //   clearcoatNormalScale: new THREE.Vector2(1),
      // });
      // const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
      // // mesh.position.set(0, 0, -200);
      // Graph.scene().add(mesh);

      //Define GUI
      const Settings = function () {
        this.rotate = false;
        this.particles = false;
        this.flatten = false;
      };

      const settings = new Settings();
      const gui = new dat.GUI();

      gui.add(settings, "rotate");
      gui.add(settings, "particles");
      gui.add(settings, "flatten");

      // rotation
      let angle = 0;
      const distance = 1000;
      setInterval(() => {
        if (settings.rotate) {
          Graph.cameraPosition({
            x: distance * Math.sin(angle),
            z: distance * Math.cos(angle),
          });
          angle += Math.PI / 300;
        }
      }, 16);

      // flatten
      function setZPosition() {
        Graph.graphData().nodes.forEach((n) => {
          n.fz = zPositionForNode(n);
        });
      }

      function zPositionForNode(node) {
        // return node.connectivity;
        return node.unknown ? -50 : 50;
        // return node.unknown ? -1500 : 50;
        // return 30 * Math.random();
      }

      Graph.onEngineTick(() => {
        // setZPosition();
        Graph.onEngineTick(() => {});
      });

      // title
      const loader = new FontLoader();
      loader.load("lib/helvetiker_regular.typeface.json", function (font) {
        const color = 0x006699;

        const matDark = new THREE.LineBasicMaterial({
          color: color,
          side: THREE.DoubleSide,
        });

        const matLite = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
        });

        const message = "SECURITY VISION";

        const shapes = font.generateShapes(message, 20); // font size

        const geometry = new THREE.ShapeGeometry(shapes);

        geometry.computeBoundingBox();

        const xMid =
          -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);

        const textHeight = 0;
        const textDepth = 1350;

        geometry.translate(xMid, textHeight, textDepth);

        // make shape ( N.B. edge view not visible )

        const text = new THREE.Mesh(geometry, matLite);
        text.position.z = -10;
        Graph.scene().add(text);

        // make line shape ( N.B. edge view remains visible )

        const holeShapes = [];

        for (let i = 0; i < shapes.length; i++) {
          const shape = shapes[i];

          if (shape.holes && shape.holes.length > 0) {
            for (let j = 0; j < shape.holes.length; j++) {
              const hole = shape.holes[j];
              holeShapes.push(hole);
            }
          }
        }

        shapes.push.apply(shapes, holeShapes);

        const lineText = new THREE.Object3D();

        for (let i = 0; i < shapes.length; i++) {
          const shape = shapes[i];

          const points = shape.getPoints();
          const geometry = new THREE.BufferGeometry().setFromPoints(points);

          geometry.translate(xMid, textHeight, textDepth);

          const lineMesh = new THREE.Line(geometry, matDark);
          lineText.add(lineMesh);
        }

        Graph.scene().add(lineText);
      });

      // Passes
      const filmPass = new FilmPass(
        0.8, // noise intensity
        0, // scanline intensity
        0, // scanline count
        false // grayscale
      );
      Graph.postProcessingComposer().addPass(filmPass);
      // const bloomPass = new UnrealBloomPass();
      // bloomPass.strength = 0.2;
      // bloomPass.radius = 1;
      // bloomPass.threshold = 0.1;
      // Graph.postProcessingComposer().addPass(bloomPass);
    </script>
  </body>
</html>
