<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
      }
    </style>

    <script src="//unpkg.com/three"></script>
    <script src="node_modules/3d-force-graph/dist/3d-force-graph.js"></script>
    <script src="//unpkg.com/dat.gui"></script>
  </head>

  <body onresize="resizeGraph()">
    <div id="3d-graph" style="width: 100%; height: 100%"></div>

    <script type="module">
      // const THREE = require("three");
      import { FilmPass } from "https://cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/FilmPass.js";
      import { UnrealBloomPass } from "https://cdn.skypack.dev/three@0.136/examples/jsm/postprocessing/UnrealBloomPass.js";

      const Graph = ForceGraph3D()(document.getElementById("3d-graph"))
        .jsonUrl("data/wiki.json")
        .nodeId("id")
        .linkSource("from")
        .linkTarget("to")
        .nodeLabel("name")
        // .nodeVal((n) => {
        //   return 1.4 ** n.size;
        // })
        .nodeThreeObject(
          (n) =>
            new THREE.Mesh(
              n.category == "institution" || n.category == "person"
                ? new THREE.SphereGeometry(1 + n.size, 0)
                : new THREE.IcosahedronGeometry(1 + n.size, 0),
              new THREE.MeshPhysicalMaterial({
                // color: Math.round(Math.random() * Math.pow(2, 24)),
                color: n.unknown ? 0x171717 : assignNodeColors(n.community),
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
                metalness: 0.9,
                roughness: 0.5,
                reflectivity: 1,
              })
            )
        )
        // .nodeAutoColorBy("community")
        .linkLabel("edge_type")
        .linkAutoColorBy("edge_type")
        .linkWidth((e) => e.edge_importance_normalised + 0.4)
        .linkCurvature(0.2)
        .linkOpacity(0.5)
        .backgroundColor("#0000ff")
        // Click on node to approach it
        .onNodeClick((node) => {
          const distance = 40;
          const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);

          Graph.cameraPosition(
            {
              // new position
              x: node.x * distRatio,
              y: node.y * distRatio,
              z: node.z * distRatio,
            },
            node, // lookAt ({ x, y, z })
            3000 // ms transition duration
          );
        });

      document.addEventListener("keydown", onDocumentKeyDown, false);
      function onDocumentKeyDown(event) {
        var keyCode = event.which;
        if (
          keyCode == 81 // q for refit view
        ) {
          Graph.zoomToFit(
            3000 // ms transition duration
          );
        } else if (keyCode == 82) {
          setZPosition();
        }
      }

      function assignNodeColors(property) {
        if (property == 1) {
          return 0xbb0000;
        } else if (property == 2) {
          return 0x00bb00;
        } else if (property == 3) {
          return 0x0000bb;
        } else {
          return 0xbbbb00;
        }
      }

      function resizeGraph() {
        if (Graph) {
          var height = document.getElementById("3d-graph").clientHeight;
          var width = document.getElementById("3d-graph").clientWidth;

          Graph.width(width);
          Graph.height(height);
          Graph.controls().handleResize();
        }
      }

      // fog
      let fogColor = new THREE.Color(0x171717);
      Graph.scene().fog = new THREE.Fog(fogColor, 100, 1500);

      // // unknown center
      // const unknownGeometry = new THREE.IcosahedronGeometry(100, 0);
      // const unknownMaterial = new THREE.MeshPhysicalMaterial({
      //   roughness: 0.2,
      //   transmission: 1,
      //   thickness: 0.1, // Add refraction!
      // });
      // const unknown = new THREE.Mesh(unknownGeometry, unknownMaterial);
      // Graph.scene().add(unknown);

      // // basic plane
      // const planeGeometry = new THREE.PlaneGeometry(1000, 1000, 1, 1);
      // const planeMaterial = new THREE.MeshLambertMaterial({
      //   color: 0x171717,
      //   side: THREE.DoubleSide,
      // });
      // const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
      // Graph.scene().add(mesh);

      // complex plane
      // const planeGeometry = new THREE.BoxGeometry(1500, 1500, 20);
      // const planeMaterial = new THREE.MeshPhysicalMaterial({
      //   color: 0x777777,
      //   roughness: 0.2,
      //   transmission: 1,
      //   thickness: 1,
      // });
      // const mesh = new THREE.Mesh(planeGeometry, planeMaterial);
      // // mesh.position.set(0, 0, -200);
      // Graph.scene().add(mesh);

      //Define GUI
      const Settings = function () {
        this.rotate = false;
        this.particles = false;
        this.flatten = false;
      };

      const settings = new Settings();
      const gui = new dat.GUI();

      gui.add(settings, "rotate");
      gui.add(settings, "particles");
      gui.add(settings, "flatten");

      // rotation
      let angle = 0;
      const distance = 1000;
      setInterval(() => {
        if (settings.rotate) {
          Graph.cameraPosition({
            x: distance * Math.sin(angle),
            z: distance * Math.cos(angle),
          });
          angle += Math.PI / 300;
        }
      }, 16);

      // flatten
      function setZPosition() {
        Graph.graphData().nodes.forEach((n) => {
          n.fz = zPositionForNode(n);
        });
      }

      function zPositionForNode(node) {
        // return node.connectivity;
        return node.unknown ? -50 : 50;
        // return node.unknown ? -1500 : 50;
        // return 30 * Math.random();
      }

      Graph.onEngineTick(() => {
        setZPosition();
        Graph.onEngineTick(() => {});
      });

      // if (settings.flatten) {
      //   setZPosition();
      // }

      // Passes
      const filmPass = new FilmPass(
        0.8, // noise intensity
        0, // scanline intensity
        0, // scanline count
        false // grayscale
      );
      Graph.postProcessingComposer().addPass(filmPass);
      // const bloomPass = new UnrealBloomPass();
      // bloomPass.strength = 0.2;
      // bloomPass.radius = 1;
      // bloomPass.threshold = 0.1;
      // Graph.postProcessingComposer().addPass(bloomPass);
    </script>
  </body>
</html>
